# VUE

## v-show 和 v-if 区别

作用：控制元素的显示和隐藏

### 不同点：

1. v-show: 使用 css 的 diaplay:none 来控制隐藏，初始化会加载一次，
2. v-if: 控制 dom 节点的删除和添加赖控制显隐，设置为 false 不会加载，初始渲染开销较小。频繁使用会不停销毁和创建 dom，消耗性能。
3. 总结：频繁操作使用 v-show，不频繁使用 v-if，

## 父子组件传值

1. 父传子：props 属性；子传父：$emit 方法
2. 子组件添加 ref 属性在父组件操作，
3. 使用$parent和$children 操作父子组件
4. 使用 vuex 进行父子传值
5. 使用$eventbus 进行传值
6. provide 和 inject 全局事件传值

## vue 的生命周期

1. beforeCreate：初始化事件，进行数据的观测，methods 和 data 读取不到
2. created：vue 实例化创建，完成了数据观测、属性和方法的运算，watch 回调，$el 属性不可见，因为还没有渲染，此时 dom 还没有挂在，允许进行 http 请求
3. beforeMount：将 HTML 解析生成 AST 节点，再根据 AST 节点动态生成渲染函数，render 函数首次调用
4. mounted：vue 实例对象添加$el 成员，并且替换掉之前的 dom 元素，挂载到页面
5. beforeUpdate：当 vue 发现 data 数据发生变化，会触发对应组件的重新渲染，当数据改变后调用
6. updated：当改变的数据渲染完成之后调用
7. beforeDestroy：在实例化销毁前调用，此时实例化仍然可以使用，清空定时器在此时
8. destroyed：在 vue 实例化销毁之后调用，调用后，vue 实例指示的东西全部解绑，所有事件监听器移除，挂载的子组件实例也会被销毁

### 初始化 ajax 请求

初始化请求一般在 created 之中完成，因为此时 data 与 methods 实例化完成，可以更快获取到服务器的数据，ssr 不支持 beforeMount 、mounted 钩子函数。

放在 mounted 之后的话在页面初次渲染完成了，先读取默认数据，在根据 ajax 返回值再次改变页面视图，进行了二次渲染，

## vue 中 data 为什么是一个方法

当定义成对象时，所有的组件共享一个 data，导致一个组件修改值，其他组件的引用也会发生变化。当定义成一个函数时，数据是函数的返回值，每个函数都会定义一个新的空间，各自维护各自的数据，不会造成混乱。

## $nextTick()作用

因为 vue 渲染 dom 是异步的，当修改了 data 的值时，马上获取 dom 的数据是获取不到更新后的值的，所以使用$nextTick()回调，让你的操作在 dom 渲染完成之后执行。

## 常用指令

v-model;v-if;v-show;v-html;v-bind;v-on;v-for

## slot 插槽

一个组件放置的内容不确定是什么类型，组件，文本或者其他时，这个位置就可以防止一个插槽。

1. 默认插槽：设置插槽的默认值，不使用的时候渲染默认值，使用的时候代替掉
2. 具名插槽：插槽添加 name 属性，使插槽具有唯一性，
3. 带参数的插槽：插槽定义时，绑定数据，使使用插槽时可以使用绑定在插槽上的数据

## watch 和 computed 的区别

### computed

1. 当一个属性收到多个属性影响的时候需要用到 computed
2. data 定义的话不能在 computed 定义
3. computed 具有缓存

### watch

1. 监听一条数据，然后进行各种操作
2. 监听复杂类型时，可使用 deep 进行深度监听
3. 需要立即执行是，使用 immediate

## MVVM 是什么

M: model
V: view
VM: viewmodel

MVVM 不同于 MVC 的层层控制，去除了 C 的控制层，使用 VM 代替，VM 是 V 和 M 的映射，操作数据来操作试图进而操作 dom，借助于 MVVM 无需直接操作 dom

关注 Model 的变化，让 MVVM 框架去自动更新 DOM 的状态，从而把开发者从操作 DOM 的繁琐步骤中解脱出来

## vue 双向绑定的原理

0. vue.js 采用的是数据劫持结合发布和-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
1. 实现一个数据监听器 Obverser，都 data 中的数据进行监听，若有变化，通知相应的订阅者。
2. 实现一个指令解析器 Compile，对于每个元素上的指令进行解析，根据指令替换数据，更新视图
3. 实现一个 Watcher，用来连接 Obverser 和 Compile，并为每个属性绑定对应的订阅者，当数据变化时，执行相应的回调函数，从而更新视图。
4. 构造函数
5. Vue 自身实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁。而数据层的 Observe 和视图层的 Compile 都是基于观察者模式实现的，再加上 Watcher 这个中间桥梁，Vue 实例能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图

## diff 算法

1. 使用了虚拟 dom 来代替真实的 dom
2. 新旧虚拟 dom 比较，如果有差异则以新的为准，然后再插入真实的 dom 重新渲染
3. 先比较同级，如果有变化则直接替换，没有变化进入下级检测
4. v-for 必须绑定 key，是一个唯一标识，可以更有效的利用虚拟 dom 的 diff 算法，找到正确的位置重新插入新的节点。但是不推荐使用 index，因为每次重新赋值 list，index 是变化的，每一个项即使没变，key 也可能发生变化，从而出发了 diff 算法，重新渲染，浪费内存

## vue-router

### 动态路由

使用 addRouter 添加。

### 导航钩子函数

1. 全局路由守卫：router.beforeEach,登录拦截在此处添加
2. 组件内的钩子函数
3. 单独路由独享组件

### 路由懒加载

1. vue 异步组件技术
2. 使用 component 直接调用 import，不在文件头部定义
3. webpack 配置

### params 传参和 query 传参区别

1. params 传参必须要用路由的 name，传参不可见，url 地址不显示，
2. query 传参需要用路由的 path，传参可见，url 地址会显示，

## vuex

vue 的状态管理工具，在 main 中引入 store，然后注入。单页面应用中组件之间的状态，

**state** 存放基本数据  
**getters** 读取 state 的值，类似于 computed，具有缓存  
**mutations** 修改 state 里面的值，所有修改 state 的操作必须在这里的方法里完成，同步的  
**actions** 异步的，一般是调用 ajax，然后调用那个 mutations 的方法以修改 state 的值  
**modules** 模块化 vuex

## vue 的优点

1. 轻量级框架，只关注视图层，是一个构建数据的视图集合
2. 简单易学，使用 html+js+css 组合方式编写代码
3. 双向数据绑定，保留了 angular 的优点，在数据操作方面更方便
4. 组件化开发，保留了 react 的优点，实现了 html 的封装和重用，
5. 视图、数据、结构分离，使数据的更改更为简单，不需要进行逻辑代码的修改，只要操作数据即可完成
6. 虚拟 dom，真实的 dom 操作是非常消耗性能的，不再使用原生 dom 操作节点，极大的解放了 dom 操作，
7. 运行速度更快，

## VUE3 和 VUE2 的区别

1. vue3.0 不在兼容 ie11
2. 相比于 2 更快，更小，更易维护，更易于原生，让开发者更轻松
3. 使用 es6 的新特性 proxy 来劫持数据，当数据改变时发出通知，
4. vue2 使用 object.defineProperty 进行数据劫持

## keep-alive 组件缓存

作用：实现组件缓存，保持组件的状态，避免反复渲染导致的性能问题

工作原理：vue 内部将 Dom 节点抽象成一个个的 vNode 节点，keep-alive 组建的缓存也是基于 VNode 节点。他将满足条件的组件在 cache 对象中缓存起来，重新渲染的时候再将 VNode 节点从 cache 对象中取出并渲染。

设置了 keep-aliv 缓存的组件，会多出俩个生命周期钩子：activeted、deactivated。

## mixin 混入

mixin 混入是一种非常灵活的方式，用来分发 vue 组件中可复用的功能。可以将多个组件用到的相同或相似的，相对独立的代码，进行抽离出来。mixin 的自身也可以使用 vue 的生命周期等自带的方法，不用了抽离 utils 方法。

mixin 混入的 data 及 methods 要早于 mixin 的组件同名的 data 属性或者 methods 方法

缺点：

1. mixin 导入的文件和 mixin 所在的文件会发生命名冲突，且 mixin 的数据发生要早。
2. mixin 命名的变量等引用来源不明确
3. minxin 和组件坑出现多对关系会使项目复杂度变高

## vue 中的修饰符

1. 表单修饰符
    1. lazy：填完信息，光标离开标签的时候，才会将值赋予 value。也就是在 change 事件之后再进行信息同步
    2. number：自动将用户输入值转化为数值类型，但如果这个值无法被 parseFloat 解析，则会返回原来的值
    3. tirm：自动过滤用户若输入的首尾空格，
2. 事件修饰符
    1. stop：阻止事件冒泡，相当于调用 event.stopPropagation
    2. prevent：组织事件的默认行为，相当于调用 event.preventDefault
    3. self：只当在 event.target 是当前元素自身时触发处理函数
    4. once：绑定了的事件只能出发第一次
    5. native：让组件变成像 html 内置标签那样监听根元素的原生事件，否则组件撒谎给你使用 v-on 只会监听自定义事件
3. 鼠标按键修饰符
   1.left：鼠标左键点击
   2.right：右键点击
   3.middle
4. 键盘修饰符
    1. 普通键（enter、tab、delete、sapce 等）
    2. 系统装饰键（ctrl、alt、meta、shift）
    3. keyup.enter：回车事件

## 对 spa 应用的理解

单页面应用，页面跳转实际上是组件接的切换，避免了真实页面跳转的缺点，

优点：

1. 具有桌面应用的即时性、网站的可移植性和可访问性
2. 用户体验好、快、内容的改变不需要重新加载整个页面
3. 良好的前后端分离、分工更明确
4. 组件化开发可以提交开发效率，

缺点：

1. 不利于 seo 优化
2. 首次渲染速度相对较慢

## ssr 理解

ssr 即服务端渲染，就是将 vue 在客户端把标签渲染成 html 的工作放在服务端完成，然后再把 html 返回给客户端

优点：有利于更好地 seo，并且首页加载速度会变快

缺点：开发条件会收到显示，服务端渲染支支持 boforeCreate 和 created 俩个钩子，当我们需要一些外部扩展库时需要特殊处理。服务端渲染应用程序也需要处理 node.js 运行环境，对服务器又更大的负载需求

## vue 的性能优化方法

1. 路由懒加载，有效拆分应用大小，访问时才异步加载
2. keep-alive 缓存页面，避免重复创建组件实例，且能保留缓存组件状态
3. v-for 遍历时避免同级使用 v-if
4. 长列表性能优化，可采用虚拟列表
5. v-once，不再变化的数据使用 v-once
6. 事件销毁，组件销毁时销毁全局变量和定时器
7. 图片懒加载
8. 第三方插件按需引入
9. 子组件分割。
10. 服务端渲染
