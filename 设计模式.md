# JS 设计模式

设计模式是面向对象设计中反复出现的问题的解决方案。它通常描述了一组相互紧密作用的类与对象。

## 设计模式的信心思想是“封装变化”

## SOLID 设计原则

1. 单一功能原则（Single Responsibility Principle）
2. 开放封闭原则（Opened Closed Principle）
3. 里氏替换原则（Liskov Substitution Principle）
4. 接口隔离原则（Interface Segregation Principle）
5. 依赖反转原则（Dependency Inversion Principle）

## 模式类别

1. 创建型

    1. 工厂模式: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使一个类的实例化延迟到其子类。
    2. 抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体类
    3. 单例模式: 保证一个类仅有一个对象，并提供一个访问它的全局访问点。
    4. 原型模式: 用于原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

2. 结构性

    1. 装饰器模式: 动态的给一个对象添加一些额外的职责。它比生成子类的方式更灵活。
    2. 适配器模式:将一个类的接口转换成客户希望的另一个接口。是的原本由于接口不兼容而不能在一起工作的那些类可以七七工作
    3. 代理模式: 为其他对象提供一个代理以控制这个对象的访问。

3. 行为型
    1. 观察者模式: 定义对象间的一种一对多的依赖关系，一边当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且自动更新。
    2. 策略模式: 定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式是的算法的变化可以独立于他的客户。
    3. 状态模式: 允许一个对象在其内部状态改变时改变他的行为。对象看起来似乎修改了他所属的类。
    4. 迭代器模式: 提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。

### 工厂模式

工厂模式就是将创建对象的过程单独封装

```js
class User {
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}
}

const a = new User("a", 1);
const b = new User("b", 2);
```

### 抽象工厂模式

抽象工厂模式是使用了抽象类的概念，理解：抽象类里定义了置位方法，此方法不能有内容，然后子类继承抽象类时，去重写这个方法。

抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。

四个关键角色：

1. 抽象工厂（抽象类，他不能被用于生成具体实例）：用于声明最终目标产品的共性，在一个系统里，抽象工厂可以有多个，每一个抽象工厂对应的这一类的产品被称为“产品族”。
2. 具体工厂（用于生成产品族里的一个具体的产品）：继承自抽象工厂，实现了抽象工厂里生命的那些方法，用于创造具体的产品类型。
3. 抽象产品（抽象类，它不能被用于生成具体实例）：
4. 具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）

抽象工厂模式的定义，是围绕一个超级工厂创建其他工厂。

### 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

每次实例化一个构造函数，都会开辟一个新的内存空间，每个实例化方法都是独立的。单例模式就是要每次实例化的都是第一次创建的那个一个实例，并让他成为唯一一个实例。

```js
const Person = (function () {
	let instance = null;
	return function () {
		if (!instance) {
			// 若这个唯一的实例不存在，那么先创建它
			class Person {}
			instance = new Person();
		}
		return instance;
	};
})();

const p1 = new Person();
const p2 = new Person();

p1 === p2; // true
```

### 原型模式

原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础。在 JavaScript 中，原型编程范式的体现就是基于原型链的继承。这其中，对原型、原型链的理解是关键。

在 JavaScript 中，我们使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享。

在 JavaScript 中，每个构造函数都拥有一个 prototype 属性，它指向构造函数的原型对象，这个原型对象中有一个 constructor 属性指回构造函数；每个实例都有一个 ——proto—— 属性，当我们使用构造函数去创建实例时，实例的——proto——属性就会指向构造函数的原型对象。

```js
        constructor>        new--->    __proto__>
原型对象 <=========> 构造函数 -----> 实例 --------> 原型对象
        <prototype
```

1. 构造函数通过 prototype 指向原型对象
2. 原型对象通过 constructor 指向构造函数
3. 通过构造函数创建实例对象
4. 实例对象通过——proto——指向原型对象
5. 实例对象调用具体的函数则是通过——proto——从自身到原型对象上查找

### 装饰器模式

### 适配器模式

### 代理模式

### 观察者模式

### 策略模式

### 状态模式

### 迭代器模式
