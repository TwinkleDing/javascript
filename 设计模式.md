# JS 设计模式

设计模式是面向对象设计中反复出现的问题的解决方案。它通常描述了一组相互紧密作用的类与对象。

## 设计模式的信心思想是“封装变化”

## SOLID 设计原则

1. 单一功能原则（Single Responsibility Principle）
2. 开放封闭原则（Opened Closed Principle）
3. 里氏替换原则（Liskov Substitution Principle）
4. 接口隔离原则（Interface Segregation Principle）
5. 依赖反转原则（Dependency Inversion Principle）

## 模式类别

1. 创建型

    1. 工厂模式: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使一个类的实例化延迟到其子类。
    2. 抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体类
    3. 单例模式: 保证一个类仅有一个对象，并提供一个访问它的全局访问点。
    4. 原型模式: 用于原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

2. 结构性

    1. 装饰器模式: 动态的给一个对象添加一些额外的职责。它比生成子类的方式更灵活。
    2. 适配器模式:将一个类的接口转换成客户希望的另一个接口。是的原本由于接口不兼容而不能在一起工作的那些类可以七七工作
    3. 代理模式: 为其他对象提供一个代理以控制这个对象的访问。

3. 行为型
    1. 观察者模式: 定义对象间的一种一对多的依赖关系，一边当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且自动更新。
    2. 策略模式: 定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式是的算法的变化可以独立于他的客户。
    3. 状态模式: 允许一个对象在其内部状态改变时改变他的行为。对象看起来似乎修改了他所属的类。
    4. 迭代器模式: 提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。

### 工厂模式

工厂模式就是将创建对象的过程单独封装

```js
class User {
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}
}

const a = new User("a", 1);
const b = new User("b", 2);
```

### 抽象工厂模式

抽象工厂模式是使用了抽象类的概念，理解：抽象类里定义了置位方法，此方法不能有内容，然后子类继承抽象类时，去重写这个方法。

抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。

四个关键角色：

1. 抽象工厂（抽象类，他不能被用于生成具体实例）：用于声明最终目标产品的共性，在一个系统里，抽象工厂可以有多个，每一个抽象工厂对应的这一类的产品被称为“产品族”。
2. 具体工厂（用于生成产品族里的一个具体的产品）：继承自抽象工厂，实现了抽象工厂里生命的那些方法，用于创造具体的产品类型。
3. 抽象产品（抽象类，它不能被用于生成具体实例）：
4. 具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）

抽象工厂模式的定义，是围绕一个超级工厂创建其他工厂。

### 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

每次实例化一个构造函数，都会开辟一个新的内存空间，每个实例化方法都是独立的。单例模式就是要每次实例化的都是第一次创建的那个一个实例，并让他成为唯一一个实例。

```js
const Person = (function () {
	let instance = null;
	return function () {
		if (!instance) {
			// 若这个唯一的实例不存在，那么先创建它
			class Person {}
			instance = new Person();
		}
		return instance;
	};
})();

const p1 = new Person();
const p2 = new Person();

p1 === p2; // true
```

### 原型模式

原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础。在 JavaScript 中，原型编程范式的体现就是基于原型链的继承。这其中，对原型、原型链的理解是关键。

在 JavaScript 中，我们使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享。

在 JavaScript 中，每个构造函数都拥有一个 prototype 属性，它指向构造函数的原型对象，这个原型对象中有一个 constructor 属性指回构造函数；每个实例都有一个 ——proto—— 属性，当我们使用构造函数去创建实例时，实例的——proto——属性就会指向构造函数的原型对象。

```js
        constructor>        new--->    __proto__>
原型对象 <=========> 构造函数 -----> 实例 --------> 原型对象
        <prototype
```

1. 构造函数通过 prototype 指向原型对象
2. 原型对象通过 constructor 指向构造函数
3. 通过构造函数创建实例对象
4. 实例对象通过——proto——指向原型对象
5. 实例对象调用具体的函数则是通过——proto——从自身到原型对象上查找

### 装饰器模式

对它已有的功能做个拓展，只关心拓展出来的那部分新功能如何实现，每次的添加，不会涉及已有的修改。

动态的给一个对象添加一些额外的职责，就扩展功能而言，要比生成子类的方法更加灵活。

### 适配器模式

适配器模式解决的是两个主体之间的对接，两个主体的关系可以是平级，也可以是上下（包含），所谓的“抹平差异”，是指固定一个对接规则（接口），两端的主体各自做适配。

1. 适配器模式：把一个类的接口转化目标的接口，实现接口的兼容性
2. 把变化留给自己，把不变留给用户

### 代理模式

在某些情况下，出于种种考虑/限制，一个对象不能直接访问另一个对象，需要一个第三者（代理）牵线搭桥从而间接达到访问目的，这样的模式就是代理模式。

1. 事件代理

    利用事件的冒泡特性，监听父元素去执行子元素的方法

    ```js
    // 获取父元素
    const father = document.getElementById("father");

    // 给父元素安装一次监听函数
    father.addEventListener("click", function (e) {
    	// 识别是否是目标子元素
    	if (e.target.tagName === "A") {
    		// 以下是监听函数的函数体
    		e.preventDefault();
    		alert(`我是${e.target.innerText}`);
    	}
    });
    ```

2. 虚拟代理
3. 缓存代理
4. 保护代理 getter、setter 保护数据

### 观察者模式

又称 发布-订阅者模式

定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新

1. 定义一个发布器类与订阅器抽象类，发布器有一个订阅列表，订阅器需要有一接收方法，
2. 将订阅器添加到发布器中，在发布器定义一个分发方法去触发订阅器的接收方法
3. 定义一个发布者继承发布器类，定义若干个订阅者继承订阅器类，将订阅者添加到发布者的订阅列表中
4. 发布者发布消息，这个消息会触发发布器的发布方法，然后发布方法再触发订阅器的方法，
5. 订阅器的方法被触发，更新获取发布器的消息，然后执行操作

### 策略模式

定义一系列的算法，把它们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可以独立于使用它的客户。

### 状态模式

策略模式每一个封装的方法都是独立的，但是状态模式的方法间存在着耦合

### 迭代器模式

提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示
